extern crate redirectionio;

#[rustfmt::skip]
mod generated_tests {

use redirectionio::router::Router;
use redirectionio::api::Rule;
use redirectionio::http::{Request, Header};
use redirectionio::action::Action;

{% for name, rule_set in rule_sets %}
fn setup_{{ name }}() -> Router<Rule> {
    let mut router = Router::<Rule>::default();
{% for _, rule in rule_set.rules %}
    let route_{{ loop.index }}: Rule = serde_json::from_str(r#"{{ rule.agentInput | json_encode() }}"#).expect("cannot deserialize");
    router.insert(route_{{ loop.index }}.into_route());
{% endfor %}
    router
}

{% for test in rule_set.tests %}
#[test]
fn test_{{ name }}_{{ loop.index }}() {
    let router = setup_{{ name }}();
    let{% if test.headers %} mut{% endif %} request = Request::new(r#"{{ test.uri }}"#.to_string(),
    {%- if test.host -%}Some(r#"{{ test.host }}"#.to_string()){% else %}None{%- endif -%},
    {%- if test.scheme -%}Some(r#"{{ test.scheme }}"#.to_string()){% else %}None{%- endif -%},
    None);
    {%- if test.headers -%}
    {% for header in test.headers %}
    request.add_header(r#"{{ header.name }}"#.to_string(), r#"{{ header.value }}"#.to_string());
    {%- endfor -%}
    {%- endif -%}
    let http_request = request.to_http_request().expect("");
    let matched = router.match_request(&http_request);

    assert_eq!(!matched.is_empty(), {{ test.match }});
{% if test.match %}
    let action = Action::from_routes_rule(matched, &http_request);
{% if test.status %}
    assert_eq!(action.get_status_code(0), {{ test.status }});
    {%- endif -%}
{% if test.location %}
    let headers = action.filter_headers(Vec::new(), 0);
    assert_eq!(headers.len(), 1);

    let target_header = headers.first().unwrap();
    assert_eq!(target_header.name, "Location");
    assert_eq!(target_header.value, r#"{{ test.location }}"#);
    {%- endif -%}
{% if test.should_filter_body %}
    let body_filter_opt = action.create_filter_body(0);
    assert_eq!(body_filter_opt.is_some(), {{ test.should_filter_body.enable }});
{% if test.should_filter_body.enable %}
    let mut body_filter = body_filter_opt.unwrap();
    let mut new_body = body_filter.filter(r#"{{ test.should_filter_body.original_body }}"#.to_string());
    new_body.push_str(body_filter.end().as_str());
    assert_eq!(new_body, r#"{{ test.should_filter_body.expected_body }}"#)
    {%- endif -%}
    {%- endif -%}
{% endif %}
{%- if test.should_filter_header and test.should_filter_header.enable %}
    let mut response_headers = Vec::new();
{% for header in test.should_filter_header.original_headers %}
    response_headers.push(Header {
        name: r#"{{ header.name }}"#.to_string(),
        value: r#"{{ header.value }}"#.to_string(),
    });
{% endfor %}
    let filtered_headers = action.filter_headers(response_headers, 0);
    let header_map = Header::create_header_map(filtered_headers);
{% for header in test.should_filter_header.expected_headers %}
    let value = header_map.get(r#"{{ header.name }}"#);

    assert!(value.is_some());
    assert_eq!(value.unwrap(), r#"{{ header.value }}"#);
{% endfor -%}
{%- endif %}
}
{% endfor %}
{% endfor %}
}
